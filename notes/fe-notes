### *Week 1*
##### _Donderdag 6 februari 2020_

#### States
* active (a:)
* hover (a:)
* default (a)
* focus (a:)
* visited (wordt bijna niet meer gebruikt)
* (in)valid
* disabled

* ::before
* ::after

transition: 1s 2s;
1s = duur animatie
2s = duur vertraging

Extra's voor animatie:
* ease
* ease-in
* ease-out
* ease-in-out
* transform:





### *Week 2*
##### _Donderdag 13 februari 2020_

[Smashing Magazine](https://www.smashingmagazine.com/2009/04/progressive-enhancement-what-it-is-and-how-to-use-it/)

#### Progressive Enhancement

Cutting the Musterd test:
Cmd + p of cmd + shift + p of control + shift + p  _in de console_
(haalt javascript weg uit de browser)

Je wil dat je website een goede ervaring geeft aan iedereen, dus ook die mensen waar JavaScript niet van toepassing is.

Kijk dus eerst naar wat wel en niet ondersteund wordt bij de gebruiker op de browser; _browser stack_.
(dit kan je checken bij _caniuse.com_)

In je CSS zou je bijvoorbeeld RGB en HSL gebruiken. Wordt HSL niet ondersteunt, dan wordt deze overgeslagen. Zo zullen oude browsers nog steeds de RGB kunnen gebruiken in plaat van de HSL.

#### Job Stories
Welke feature wil je maken?
Moet kunnen werken *zonder enhancent* van JavaScript!
Dit betekend dat je de extra styling van je pagina zonder JavaScript zou kunnen doen.

En denk aan je Progressive Enhancement:
* html
* css
* js

#### In de database _zonder_ JavaScript
Zoek informatie over de <form>
*action tag
*method tag

Frontend = de laptop
Backend  = de server (node) _we weten dat de server JS kan gebruiken, dus we kunnen wel JS gebruiken om data op te halen via de server.
Database = de data

--------------------------------------------------------------------------------------

typeof 42
> 'number'

typeof typeof 42
> 'string'




var number = [10, 20, 30, 40];

for (var indeex = 0; index <number.length; index++) {
    console.log(index, number[index]);
};

> 0 10
> 1 20
> 2 30
> 3 40
> undefined

var number = [10, 20, 30, 40];

for (var indeex = 0; index <number.length; index++) {
    setTimeout (function() {
    console.log(index, number[index]);
    }, 1000);
};

> 4 undefined

JavaScript gaat door met de forloop, dit betekend dat de uitkomst al 4 keer is geloopt, en het laatste resultaat is >undefined, dus deze krijg je ook te zien in je console,

--------------------------------------------------------------------------------------

*Duidelijkheid staat _boven alles_ in JavaScript*

----------------------------------------------------------------------------------


### *Week 3*
##### _Donderdag 27 februari 2020_

#### DOM Node

* node      = een HTML element
* tag name  = de naam van het element

HTML - body - script

            - p - span
                - span

            - h1 - span


* parentNode    = naar boven in de boom
* childNode     = naar beneden in de boonm

GetElementByTag = altijd een array van bijv alle span

## Recursive function

*Recursion* heeft nodig:
* call naar zichzelf
* end state/condition - wanneer er geen children meer zijn in de boom



----------------------------------------------------------------------------------
function recus(data, tries) {
    if(tries === 10) {
        return data;
    }

    if(data!) {
        data = []
    }

    data.push(tries);
    return recur(data, tries+1);
}

recur (null, 0)
> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]






<h1>Heading with a <span>span</span> element.</h1>
<p>A paragraph with <span>one</span>, <span>two</span>
  spans.</p>

<script>
  function byTagName(node, tagName) {
    *// Your code here.*
  }

  console.log(byTagName(document.body, "h1").length);
  // → 1
  console.log(byTagName(document.body, "span").length);
  // → 3
  let para = document.querySelector("p");
  console.log(byTagName(para, "span").length);
  // → 2
</script>


*// Your code here.*
function byTagName(node, tagName) {
    console.log(node, tagName);
  }

  > HTMLBodyElement{} h1


*// Your code here.*
function byTagName(node, tagName) {
    var currentTagName = node.nodeName;

    console.log(node, tagName);
  }

> BODY h1

*// Your code here.*
function byTagName(node, tagName) {
    var currentTagName = node.nodeName;
    var currentTagNameLowerCase = currentTagName.toLowerCase();

    console.log(node, tagName);
  }

> body h1
----------------------------------------------------------------------------------

Wat je wil is dat je code door de boom gaat en alles vergelijkt met de tagName die je wil hebben (bijv h1), dan kijk je of die tak een child heeft, wel, dan gaat de code nog een keer doorheen, niet, stopt de code.


#### *GOEIE CODE* get ellements by tagName

<script>
    function byTagName(node, tagName) {
    var nodes = [];

    checkTagName(node, tagName);

    return nodes

    function checkTagName(node, tagName) {
        var currentTagName = node.nodeName;
        var currentTagNameLowerCase = currentTagName.toLowerCase;
        var children = node.childrenNodes;

        if(currentTagNameLowerCase === tagName) {
            nodes.push(node);
        }

        if(children) {
            for(var index = 0 index < children.lenght - 1; index++) {
                checkTagName(children[index], tagName);
            }
        }
      }
    }

console.log(
    byTagName(document.body, "span")
);
</script>


### *Week 4*
##### _Donderdag 5 maart 2020_

#### Events
Interactie van user op de DOM

(document)
* .getElementByID
* .getElementByTag

Je pakt een button via de getElement
Maar hij werkt pas als je hem koppeld aan JS met .addEventListener

> addEventListener('click', function(event){
> console.log(event);
> });

* (onclick kan ook, maar is verouderd)
* touch Event - event.touch
  * touch start (voor swipen)
  * touch end (voor swipen)

* MouseEvent - event.mouse - zie waar je voor het laatst hebt gedrukt met de muis met x- en y- as
  * click event
  * target - zo kan je buiten de model klikken en de model afsluiten

* keyboard event - event.key
  * key up
  * key down

  (wanneer je op het donkere klikt achter de reclame bijv)

> document. - info wordt gehaald uit de DOM
> window.   - info worj

Model - forceerd je te kijken naar dat onderdeel door de achtergrond donker te maken bijv.

Events
- gaan van de window naar de target en dan weer terug naar de window
  je klikt dus op de window en op de butten tegelijk wanneer je klikt op het scherm

{name:'henk'} - dit staat in je RAM geheugen
Elke functie wordt aangemaakt en opgeslagen in de geheugen

Als je dit wil veranderen moet je een functie maken die die functie weer verwijderd


#### Timers
.setTimeout

* setTimeout
* clearTimeout

> => === function()

var bombTimer = setTimeout( => {
console.log('BOOM!');
}, 500);

- 500 staat voor 500 ms

*Asychronise programming*:

* Wanneer je een functie niet meer nodig hebt in je JS omdat hij al naar de browser is gestuurd
* Zo kan JS gewoon verder met lezen
* Nadat de functie is gebruikt op de browser,
* wordt het weer teruggestuurd naar de JS

- _Dit zorgt ervoor dat je JS niet hoeft te wachten met het uitlezen van je code_

#### Debouncing
- kijkt hoelaang je _niet_ aan het typen bent.

Zo roep je niet de hele tijd API's aan, maar alleen wanneer je een tijd niet hebt getyped.
Dit is bijvoorbeeld handig wanneer je autocomplete wil toevoegen

#### HTTP

router.get  - als je naar een url gaat
router.post - als je info naar de database wil sturen

<form method='get' action='example/message.html'>

#### Fetch
- browser API

Doet een request naar een server waardoor je acties en reacties krijgt.
Form tag maar dan met JS

#### Promises
Async

setTimeout - Promises
_zelfde functie, anders opgeschreven_

fetch('http//blabla.nl')
> promise {<pending>}

Er wordt gewacht totdat er data wordt teruggestuurd

fetch('url')
 .then(function(response) {
    console.log(response);
 })

 .catch(function(error) {
    console.log(error);
 })
